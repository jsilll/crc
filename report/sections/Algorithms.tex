\label{Algorithms}

\subsection{Degree Pruning Algorithm}

\subsubsection{Overview}

The degree-running algorithm is a widely used and efficient method for discovering k-cores within a graph. It accomplishes this by utilizing the concept of "vertex degree," which denotes the number of edges connected to a vertex. This algorithm progressively removes vertices and edges with degrees less than the desired k, ultimately revealing the k-core structure of the graph. It is especially effective in scenarios where the graph is sparse or moderately dense, making it a valuable tool for various network analysis tasks. In summary, the algorithm leverages vertex degrees to iteratively prune the graph until the desired k-core is achieved, providing insights into network organization.

Initially, the algorithm calculates the degree of every node and enqueues nodes with degrees less than $k$. Subsequently, it dequeues nodes from the queue one at a time, removes them from the graph, and decreases the degrees of their neighbors. If, at any stage, a node's degree falls below $k$, it is also placed in the queue for removal. Ultimately, only the k-core of the graph remains intact after this process. A pseudo-code for the algorithm in question can be found in algorithm \ref{algo:Degree_prunning}

\begin{algorithm}[ht]
  \label{algo:Degree_prunning}
  \caption{Degree-Pruning Algorithm for Finding K-Cores}
  \KwData{Graph $G$, integer $k$}
  \KwResult{K-core of the graph $G$}
  
  \textbf{Let} $q$ be an empty queue\;
  \textbf{Let} $degree$ be an array of size $|V(G)|$ with all elements set to $0$\;
  
  \For{$vertex$ in $G$}{
    $d \leftarrow$ \textbf{degree of $vertex$ in $G$}\;
    \If{$d < k$}{
      \textbf{enqueue} $vertex$ into queue $q$\;
    }
    $degree[vertex] \leftarrow d$\;
  }
  
  \While{$q$ is not empty}{
    $u \leftarrow$ \textbf{dequeue} a vertex from queue $q$\;
    
    \For{each vertex $v$ adjacent to $u$ in $G$}{
      \If{$degree[v] \geq k$}{
        $degree[v] \leftarrow degree[v] - 1$\;
        \If{$degree[v] < k$}{
          \textbf{enqueue} vertex $v$ into queue $q$\;
        }
      }
    }
    
    \textbf{remove} vertex $u$ from graph $G$\;
  }
  
  \Return{$G$} \tcp{K-core of the graph}
\end{algorithm}

\subsubsection{Space Complexity}

Computing the space complexity of this algorithm is trivial, since it uses a vector of size $|G|$ and a queue that can have atmost the same size. Thus, we can say that the space complexity is $O(|G|)$, meaning that the space complexity is $O(V)$.

\subsubsection{Time Complexity}

The time complexity will depend on two factors: the dequeuing (which has a time complexity of $O(V)$, since if there is no k-core all nodes will end up in the queue) loop and visiting the neighbours (which has a time complexity, in the worst case, equal to the number of edges, $O(E)$). Therefore, the final complexity is $O(V + E)$. Not that the number $k$ influences the complexity, because nodes are added to the queue, and, consequently more neighbours are visited, based on the relationship between their degree and $k$